
    "def addProcess_2S(tmax=300, lama=30, l_lamd=[30], l_nbPers=[0]):\n",
    "    \n",
    "    lTmps = [0]\n",
    "    t = 0.0  # temps du derniere evenement\n",
    "    assert len(l_lamd) == len(l_nbPers)\n",
    "    nbService = len(l_lamd)\n",
    "    # None represente une valeur a definir dans la boucle\n",
    "    dta = None  # delta inter arrivee\n",
    "    dtd = nbService * [None]  # deltas inter departs\n",
    "    cpt = l_nbPers \n",
    "    cpt_T = [np.copy(cpt)]  # liste qui accumule les etats des files d'attente a chaque evenement \n",
    "        \n",
    "    while True:\n",
    "\n",
    "        # dtdMin = np.argmin(dtd)\n",
    "        # cptMin = np.argmin(cpt)\n",
    "        \n",
    "        if dta is None:\n",
    "            # la prochaine arrivee n'est pas definie, on la redefinie \n",
    "            dta = np.random.exponential(lama)\n",
    "            \n",
    "        for i in range(nbService):\n",
    "            if dtd[i] is None and cpt[i] > 0:\n",
    "                # le prochain depart n'est definie pour cette file, on le redefini\n",
    "                dtd[i] = np.random.exponential(l_lamd[i])\n",
    "        \n",
    "        # on recherche le delta le plus proche dans le temps\n",
    "        dtdMin = np.inf\n",
    "        imin = None\n",
    "        for i in range(nbService):\n",
    "            if dtd[i] is not None and dtdMin > dtd[i]:\n",
    "                dtdMin = dtd[i]\n",
    "                imin = i\n",
    "            \n",
    "        if imin is not None:\n",
    "            # cas ou l'arrivee est en concurence avec les departs\n",
    "            if dtd[imin] > dta:\n",
    "                #l'arrivee se produit avant les desparts\n",
    "                cptMin = np.inf\n",
    "                cpt_i = None\n",
    "                t += dta\n",
    "                for i in range(nbService):\n",
    "                    if dtd[i] is not None:\n",
    "                        dtd[i] -= dta\n",
    "                    if cpt[i] < cptMin:\n",
    "                        cptMin = cpt[i]\n",
    "                        cpt_i = i   \n",
    "                cpt[cpt_i] += 1\n",
    "                dta = None          \n",
    "            else:\n",
    "                # le depart le plus proche se produit avant la prochaine arrivee\n",
    "                t += dtd[imin]\n",
    "                dta -= dtd[imin]\n",
    "                for i in range(nbService):\n",
    "                    if dtd[i] is not None:\n",
    "                        dtd[i] -= dtd[imin]\n",
    "                dtd[imin] = None\n",
    "                cpt[imin] -= 1\n",
    "        \n",
    "        else:\n",
    "            #cas ou l'arrivee est la seul possibilitee\n",
    "            t += dta\n",
    "            k = np.random.randint(nbService)  # choix d'une file au hasard\n",
    "            cpt[k] += 1\n",
    "            dta = None  \n",
    "            \n",
    "        #verification de si on ne depasse pas les bornes de la simulation\n",
    "        if t > tmax:\n",
    "            break\n",
    "\n",
    "        lTmps.append(t)\n",
    "        cpt_T.append(np.copy(cpt))\n",
    "        \n",
    "    return lTmps,cpt_T  "
    
